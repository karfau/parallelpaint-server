package services;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import model.Drawing;
import model.Element;
import model.ElementSelection;
import model.PPUser;

import org.springframework.beans.factory.annotation.Required;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.flex.messaging.AsyncMessageCreator;
import org.springframework.flex.messaging.MessageTemplate;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import exceptions.DrawingNotFoundException;
import exceptions.ElementNotFoundException;
import exceptions.IsAllreadyAVersionOfADrawingException;
import exceptions.OperationNotAllowedException;
import flex.messaging.messages.AsyncMessage;
import flex.messaging.util.UUIDUtils;

/*
 * Ein Service, der ohne DAO arbeitet und daher auch im Spring-Sinne ein Repository ist.
 */

@Repository
public class ElementPersistanceService implements IElementPersistanceService {

	private static final String MESSAGE_TYPE_ADD_ELEMENT = "addElement";
	private static final String MESSAGE_TYPE_UPDATE_ELEMENT = "updateElement";
	private static final String MESSAGE_TYPE_REMOVE_ELEMENT = "removeElement";

	private static final String MESSAGE_TYPE_SELECT_ELEMENT = "selectElement";

	private static final String MESSAGE_TYPE_UNSELECT_ELEMENT = "unselectElement";

	@PersistenceContext
	private EntityManager em;

	// allows for easily send Flex Messages
	private MessageTemplate msgTemplate;

	@Required
	public void setMsgTemplate(MessageTemplate template) {
		this.msgTemplate = template;
	} // setMsgTemplate

	@Override
	@Transactional
	public Drawing createDrawing() {
		Drawing newDrawing = new Drawing();

		//assign the author / authkey
		String authkey = getCurrentAuthenticatedUserName();
		if(authkey.equalsIgnoreCase(PPUser.ANONYMOUS_USER_NAME))
			authkey = UUIDUtils.createUUID();
		newDrawing.setAuthor(authkey );

		em.persist(newDrawing);
		em.flush();
		em.refresh(newDrawing);
		return newDrawing;
	} // createDrawing


	@Override
	@Transactional
	public long setRegisteredDrawingAuthor(long drawingId, String authorKey) throws
	  DrawingNotFoundException, OperationNotAllowedException {

		Drawing drawing = findDrawingById(drawingId);
		if(drawing == null)
			throw new DrawingNotFoundException();
		else if( ! drawing.getAuthor().equals(authorKey))
			throw new OperationNotAllowedException("wrong authorKey");

		drawing.setAuthor(getCurrentAuthenticatedUserName());
		// only required if Drawing entity is in detached state
		drawing = em.merge(drawing);
		return drawing.getId();
	} // setRegisteredDrawingAuthor

	@Override
	@Transactional
	public long addElement(Element element) {
		//TODO: sideeffect on selection?
		// received element's id is always -1 at his point, so no if/else necessary
		element.setId(null);
		em.persist(element);
		// after flush call an ID was generated by the JPA provider
		em.flush();
		em.refresh(element);

		// get the Drawing entity from DB, in which this Element is contained
		// TODO: Test auf nicht-vorhandenes Drawing
		Drawing enclosingDrawing = em.find(Drawing.class, element.getDrawingId());
		// set Id of enclosing drawing in Element
		element.setDrawingId(enclosingDrawing.getId());
		// add this Element-Entity to the Drawing-Entity's list of Elements
		enclosingDrawing.getElements().add(element);

		// *bi*directional relationship!
		// (from Element --> Drawing)
		element.setDrawing(enclosingDrawing);

		// IMPORTANT: merge detached entity (cause: closed transaction) into persistence context!
		// (so the *newly* added Element gets also added to the *existing* Drawing entity)
		enclosingDrawing = em.merge(enclosingDrawing);

		System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> " +
				"'enclosingDrawing' with 'id' " + enclosingDrawing.getId() +
				" has following elements: ");
		for (Element el : enclosingDrawing.getElements()) {
			System.out.println("element with 'id': " + el.getId());
		} // for
		System.out.println("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ");



		sendDrawingSubtopicMessage(element.getDrawingId(),
								   MESSAGE_TYPE_ADD_ELEMENT,
								   createLightweightElementForSending(element));
								   //element);
		return element.getId();
	} // addElement

	@Transactional
	public Drawing findDrawingById(long drawingId) throws DrawingNotFoundException {
		//TODO: sideeffect on selection?

		//FIXME: unmapped exception if drawingId doesn't exist: org.springframework.dao.InvalidDataAccessApiUsageException : Can not refresh not managed object: null.; nested exception is java.lang.IllegalArgumentException: Can not refresh not managed object: null."

		/* TODO: put next line in try-block an catch Springs runtime exception
		 * EmptyResultDataAccessException and throw new domain exception
		 * 'DrawingNotFoundException'
		 */

		// use persistence context to retrieve Drawing entity instead of query the DB
		Drawing requestedDrawing = em.find(Drawing.class, drawingId);

		// overwrite the state of the entity in persistence context with the one from DB
		em.refresh(requestedDrawing);

		// no Drawing Entity found
		if (requestedDrawing == null) {
			throw new DrawingNotFoundException();
		} // if
		return requestedDrawing;
	} // findDrawingById

	@Transactional
	public void updateElement(Element element) {
		//TODO: sideeffect on selection?

		// get requested Element from DB (using Named Query from Element.java)
		Element elementToUpdate = em.createNamedQuery(
								  "Element.findElementByDrawingIdAndElementId", Element.class)
								  .setParameter("drawingId", element.getDrawingId())
								  .setParameter("elementId", element.getId())
								  .getSingleResult();
		/*
		 * FIXME: unmapped Exception org.springframework.dao.EmptyResultDataAccessException :"getSingleResult() did not retrieve any entities."
		 * should result in a ElementNotFoundException
		 */

		// update: merge the Element entity from DB with the given *detatched* Element entity
		elementToUpdate = em.merge(element);

		// re-set Drawing to establish Many-to-One relationship
		elementToUpdate.setDrawing(em.find(Drawing.class, element.getDrawingId()));

		// increase elementVersion for client (to avoid flickering)
		elementToUpdate.setElemVersion( elementToUpdate.getElemVersion() + 1 );

		// send the updated Element to the clients
		sendDrawingSubtopicMessage(
				elementToUpdate.getDrawingId(),
				MESSAGE_TYPE_UPDATE_ELEMENT,
				createLightweightElementForSending(elementToUpdate));
				//elementToUpdate);
	} // updateElement

	@Transactional
	public void removeElement(Long elementId) throws ElementNotFoundException {
		//TODO: sideeffect on selection?
		Element elementToRemove =   em.createNamedQuery(
									"Element.findElementById", Element.class)
									.setParameter("elementId", elementId)
									.getSingleResult();

	    if (elementToRemove != null) {
	    	em.remove(elementToRemove);
	    	sendDrawingSubtopicMessage(elementToRemove.getDrawingId(),
	    			                   MESSAGE_TYPE_REMOVE_ELEMENT,
	    			                   elementId);
	    }
	    else {
	    	throw new ElementNotFoundException("class: ElementPersistenceService | method: removetElement");
	    } // if-else

	    /*
	     * #########################################
	     * >   Drawing-Versioning-"Test" ::BEGIN   <
	     * #########################################
	     */

//	    try {
//			createVersionOfDrawing(elementToRemove.getDrawingId(), "");
//		} catch (DrawingNotFoundException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		} catch (IsAllreadyAVersionOfADrawingException ex) {
//			// TODO Auto-generated catch block
//			ex.printStackTrace();
//		} // try-catch

		/*
	     * #########################################
	     * >   Drawing-Versioning-"Test" ::END   <
	     * #########################################
	     */

	} // removeElement

	private String getCurrentAuthenticatedUserName() {
		return SecurityContextHolder.getContext().getAuthentication().getName();
	} // getCurrentAuthenticatedUserName

	private void sendDrawingSubtopicMessage(final long drawingId, final String messageType, final Object body) {
		this.msgTemplate.send(new MessageCreator("ppd_" + drawingId, messageType, body));
	}
	private void sendSelectionMessage(final ElementSelection selection, final boolean select) {
		this.msgTemplate.send(new MessageCreator(	"ppd_" + selection.drawingId,
																select ? MESSAGE_TYPE_SELECT_ELEMENT : MESSAGE_TYPE_UNSELECT_ELEMENT,
																selection.elementId));
	}

	@Override
	@Transactional
	public String selectElement(Long elementId) throws ElementNotFoundException {

		// find drawingId for element to get the subtopic or throw ElementNotFoundException
		Element element = em.find(Element.class, elementId);
		if (element==null) {
			throw new ElementNotFoundException("class: ElementPersistenceService | method: selectElement");
		} else {

			synchronized (selections) {
				ElementSelection selection = findSelectionForId(elementId);
				String username = getCurrentAuthenticatedUserName();
				/* If selection is not null some user has already selected it:
				 * it can not be selected "again" or by another user.
				 */
				if(selection==null){
					selection = new ElementSelection(elementId, element.getDrawingId(), username, System.currentTimeMillis());
					selections.add(selection);
					sendSelectionMessage(selection, true);
					return username;
				}else if(selection.isSelector(username)){
					return username;
				}else{
					return selection.getSelector();
				}
			}
		}
	}

	@Override
	@Transactional
	public String unselectElement(Long elementId) throws ElementNotFoundException {

		System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> in 'unselectElement' " +
				"'elementId' argument is: " + elementId);

		//Element element = em.find(Element.class, elementId);
//		Element element = em.createNamedQuery("Element.findElementById",Element.class)
//		                  .setParameter("elementId", elementId)
//						  .getSingleResult();
//
//		if (element==null) {
//			throw new ElementNotFoundException("class: ElementPersistenceService | method: unselectElement");
//		} else {
			synchronized (selections) {
				ElementSelection selection = findSelectionForId(elementId);
				//TODO: extract function removeElementSelection
				if(selection!=null && selection.isSelector(getCurrentAuthenticatedUserName())){
					selections.remove(selection);
					sendSelectionMessage(selection, false);
					selection = null;
				}
				return selection != null ? selection.getSelector() : null ;
			}
//		}
	}

	/* Selects the given element and unselects all other elements from the selector
	 */
	@Override
	@Transactional
	public String selectSoleElement(Long elementId) throws ElementNotFoundException {

		System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> in 'selectSoleElement' " +
				"'elementId' argument is: " + elementId);

		//Element element = em.find(Element.class, elementId);
		Element element = em.createNamedQuery("Element.findElementById",Element.class)
        				  .setParameter("elementId", elementId)
        				  .getSingleResult();

		if (element==null) {
			throw new ElementNotFoundException("class: ElementPersistenceService | method: selectSoleElement");
		} else {
			synchronized (selections) {
				ElementSelection selection = findSelectionForId(elementId);
				String username = getCurrentAuthenticatedUserName();
				if(selection==null){
					selection = new ElementSelection(elementId, element.getDrawingId(), username, System.currentTimeMillis());

					//remove all current selections
					ElementSelection selectionToRemove;
					for (Iterator<ElementSelection> it = selections.iterator(); it.hasNext();) {
						selectionToRemove = it.next();
						if (selectionToRemove.isSelector(username)) {
							it.remove();//it has reference to current value
							sendSelectionMessage( selectionToRemove, false);
						} // if
					} // for
					selections.add(selection);
					sendSelectionMessage(selection,true);
					return username;
				}else if(selection.isSelector(username)){
					return username;
				}else{
					return selection.getSelector();
				}//else
			} // synchronized
		} // if-else
	} // selectSoleElement


	private ArrayList<ElementSelection> selections = new ArrayList<ElementSelection>();

	// helper method for selection/unselection
	private ElementSelection findSelectionForId(final Long elementId){
		//TODO could be filtered by timestamp if to long in past
		for(ElementSelection selection : selections){
			if(selection.elementId == elementId){
				return selection;
			}
		}
		return null;
	} // findSelectionForId

	@Transactional
	public long createVersionOfDrawing(Long originalDrawingId, String versionTag) throws
		// method creates a new version of an existing Drawing
		// (only if existing Drawing is not allready a version of another Drawing)
		DrawingNotFoundException, IsAllreadyAVersionOfADrawingException {

		Drawing originalDrawing = null;
		try {
			originalDrawing = em.find(Drawing.class, originalDrawingId);
		} catch (EmptyResultDataAccessException erdae) {
			throw new DrawingNotFoundException();
		} // try-catch
		if (originalDrawing.getVersionOf() != 0L) throw new IsAllreadyAVersionOfADrawingException();
		// constructs a new version of the original Drawing entity
		// identified by the given originalDrawingId argument
		Drawing versionDrawing = new Drawing(originalDrawing, versionTag);
		// make the newly constructed Drawing a managed one
		versionDrawing = em.merge(versionDrawing);
		// adjust the drawingId propert of all contained Element entities
		settingOfdrawingIdForAllContainedElements(versionDrawing);
		return versionDrawing.getId();
	} // createVersionOfDrawing

	@Transactional
	public List<Drawing> getAllVersionsOfDrawing(Long originalDrawingId) {
		/*
		 *  TODO: Throw a special Exception if this method gets called
		 *        with an Id of a Drawing entity which is allready a version
		 *        of another Drawing entity --> no version allowed for "version Drawings"!
		 */
		return em.createNamedQuery("Drawing.findAllVersionsOfDrawingByIdOfOriginalDrawing",
				                    Drawing.class)
				                    .setParameter("originalDrawingId", originalDrawingId)
				                    .getResultList();
	} // getAllVersionsOfDrawing

	private void settingOfdrawingIdForAllContainedElements(Drawing drawing) {
		/*
		 * helper method for setting the property 'drawingId' of every
		 * contained Element (in the list property 'elements') to the
		 * Id of *this* Drawing entity (which is the enclosing Drawing
		 * for the contained Element entities)
		 * >>>  SHOULD ONLY BE CALLED AFTER THE ARGUMENT 'drawing' IS IN PERSISTENCE CONTEXT!  <<<
		 */
		for (Element el : drawing.getElements()) {
			el.setDrawingId(drawing.getId());
		} // for
	} // settingOfdrawingId

	private Element createLightweightElementForSending(Element element) {
		/*
		 * helper method which (1) creates a new "Deep Copy" of the given Element
		 * 'element' and (2) removes for the given Element the reference to a Drawing
		 * entity (so the referenced Drawing itself and all other Element entities
		 * contained in this Drawing are *not* transmitted over the wire to save bandwidth)
		 */
		Element elemForSending = element.createDeepCopy();
		elemForSending.setDrawing(null);
		return elemForSending;
	} // prepareElementForSending

	// ----------------------------------------------------------------------------------------------

	// inner class for sending Flex Messages
	private class MessageCreator implements AsyncMessageCreator {

		private final String DESTINATION = "chat";
		private final String HEADER_MESSAGETYPE = "MESSAGETYPE";
		private final String HEADER_SENDING_USER = "SENDING_USER";

		private final String messageType;
		private final Object body;
		private final String subtopic;

		public MessageCreator(String subtopic, String messageType, Object body) {
			this.subtopic = subtopic;
			this.messageType = messageType;
			this.body = body;
		}

		@Override
		public AsyncMessage createMessage() {
			AsyncMessage msg = msgTemplate.createMessageForDestination(DESTINATION);
			msg.setHeader(HEADER_MESSAGETYPE, messageType);
			msg.setHeader(HEADER_SENDING_USER, getCurrentAuthenticatedUserName());
			msg.setHeader(AsyncMessage.SUBTOPIC_HEADER_NAME, subtopic);
			msg.setBody(body);
			return msg;
		} // createMessage

	} // inner class MessageCreator

} // class
